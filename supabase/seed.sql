-- TABLES
create table public.allowed_domains (
    domain text not null,
    constraint allowed_domains_pkey primary key (domain),
    constraint allowed_domains_domain_key unique (domain)
) tablespace pg_default;

create table public.activities (
    id uuid not null default gen_random_uuid (),
    title text not null,
    description text null,
    visibility public.activity_visibility not null default 'Everyone' :: activity_visibility,
    date_starting timestamp with time zone null,
    date_ending timestamp with time zone null,
    created_at timestamp with time zone not null default (now() at time zone 'utc' :: text),
    updated_at timestamp with time zone null default (now() at time zone 'utc' :: text),
    created_by uuid not null default auth.uid (),
    series uuid null,
    image_url text null,
    constraint activities_pkey primary key (id),
    constraint activities_title_key unique (title),
    constraint activities_created_by_fkey foreign key (created_by) references users (id) on update cascade on delete
    set
        null,
        constraint activities_series_fkey foreign key (series) references series (id) on update cascade on delete
    set
        null
) tablespace pg_default;

create table public.faculty_assignments (
    id bigint generated by default as identity not null,
    activity_id uuid null,
    user_id uuid null,
    created_at timestamp with time zone not null default now(),
    constraint activity_handlers_pkey primary key (id),
    constraint activity_handlers_id_key unique (id),
    constraint activity_handlers_activity_id_fkey foreign key (activity_id) references activities (id) on update cascade on delete cascade,
    constraint activity_handlers_user_id_fkey foreign key (user_id) references users (id) on update cascade on delete cascade
) tablespace pg_default;

-- for upserting data
create unique index if not exists faculty_assignments_activity_id_user_id_idx on public.faculty_assignments using btree (activity_id, user_id) tablespace pg_default;

create table public.series (
    id uuid not null default gen_random_uuid (),
    title text not null,
    created_at timestamp with time zone not null default now(),
    color text null,
    constraint series_pkey primary key (id),
    constraint activity_groups_title_key unique (title),
    constraint series_color_check check ((length(color) <= 10))
) tablespace pg_default;

create table public.users (
    id uuid not null default auth.uid (),
    email text not null,
    name text not null,
    avatar_url text null default '' :: text,
    role public.roles_user null,
    active boolean not null default true,
    updated_at timestamp with time zone not null default (now() at time zone 'utc' :: text),
    created_at timestamp with time zone not null default (now() at time zone 'utc' :: text),
    department public.roles_dept not null default 'na' :: roles_dept,
    other_roles roles_pos [] null,
    constraint users_pkey primary key (id),
    constraint users_email_key unique (email),
    constraint users_id_key unique (id)
) tablespace pg_default;

create table public.activity_files (
    id uuid not null default gen_random_uuid (),
    name text not null default '' :: text,
    checksum text not null default '' :: text,
    activity uuid not null default gen_random_uuid (),
    uploaded_at timestamp with time zone not null default (now() at time zone 'utc' :: text),
    type text not null default '???' :: text,
    constraint activity_files_pkey primary key (id),
    constraint activity_files_activity_fkey foreign key (activity) references activities (id) on update cascade on delete cascade
) tablespace pg_default;

create trigger update_raw_app_meta_data_trigger
after
update
    of role,
    active on users for each row
    when (
        old.role is distinct
        from
            new.role
            or old.active is distinct
        from
            new.active
    ) execute function update_raw_app_meta_data ();

-- VIEWS
create view public.activities_details_view with (security_invoker = on) as
select
    activities.id,
    activities.title,
    activities.description,
    series.title as series,
    series.color as series_color,
    activities.visibility,
    activities.image_url,
    activities.date_starting,
    activities.date_ending,
    activities.created_at,
    activities.updated_at,
    users.name as created_by,
    users.email as creator_email,
    users.avatar_url as creator_avatar
from
    activities
    left join users on activities.created_by = users.id
    left join series on activities.series = series.id;

create view public.activities_faculties_view
with (security_invoker = on)
as
select
    activities.id as activity_id,
    users.id as faculty_id,
    users.name as faculty_name,
    users.email as faculty_email,
    users.avatar_url as faculty_avatar
from
    faculty_assignments
    left join activities on activities.id = faculty_assignments.activity_id
    left join users on users.id = faculty_assignments.user_id;

create view
    public.activities_subscriptions_view
    with (security_invoker = on)
    as
select
    activities.id as activity_id,
    users.id as subscriber_id,
    users.name as subscriber_name,
    users.email as subscriber_email,
    users.avatar_url as subscriber_avatar
from
    activity_subscriptions
    left join activities on activities.id = activity_subscriptions.activity_id
    left join users on users.id = activity_subscriptions.user_id;
