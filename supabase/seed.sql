-- TABLES
create table public.allowed_domains (
    domain text not null,
    constraint allowed_domains_pkey primary key (domain),
    constraint allowed_domains_domain_key unique (domain)
) tablespace pg_default;

create table
  public.activities (
    id uuid not null default gen_random_uuid (),
    title text not null,
    description text null,
    visibility public.activity_visibility not null default 'Everyone'::activity_visibility,
    date_starting timestamp with time zone null,
    date_ending timestamp with time zone null,
    created_at timestamp with time zone not null default (now() at time zone 'utc'::text),
    updated_at timestamp with time zone null default (now() at time zone 'utc'::text),
    created_by uuid not null default auth.uid (),
    series uuid null,
    image_url text null,
    objectives text[] not null default '{}'::text[],
    feedback boolean not null default false,
    outcomes text[] not null default '{"''Key Outcomes''","''Impact on Community''","''Success Indicators''","''Overall Achievement Level''"}'::text[],
    constraint events_pkey primary key (id),
    constraint events_title_key unique (title),
    constraint events_created_by_fkey foreign key (created_by) references users (id) on update cascade on delete set null,
    constraint events_series_fkey foreign key (series) references series (id) on update cascade on delete set null
  ) tablespace pg_default;

create index if not exists activities_date_starting_date_ending_idx on public.activities using btree (date_starting, date_ending) tablespace pg_default;

create table public.faculty_assignments (
    id bigint generated by default as identity not null,
    activity_id uuid null,
    user_id uuid null,
    created_at timestamp with time zone not null default now(),
    constraint activity_handlers_pkey primary key (id),
    constraint activity_handlers_id_key unique (id),
    constraint activity_handlers_activity_id_fkey foreign key (activity_id) references activities (id) on update cascade on delete cascade,
    constraint activity_handlers_user_id_fkey foreign key (user_id) references users (id) on update cascade on delete cascade
) tablespace pg_default;

-- for upserting data
create unique index if not exists faculty_assignments_activity_id_user_id_idx on public.faculty_assignments using btree (activity_id, user_id) tablespace pg_default;

create table
  public.series (
    id uuid not null default gen_random_uuid (),
    title text not null,
    created_at timestamp with time zone not null default now(),
    color text null,
    constraint series_pkey primary key (id),
    constraint event_groups_title_key unique (title),
    constraint series_color_check check ((length(color) <= 10))
  ) tablespace pg_default;

create table
  public.users (
    id uuid not null default auth.uid (),
    email text not null,
    name text not null default 'Unverified User'::text,
    avatar_url text null default ''::text,
    role public.roles_user null default 'student'::roles_user,
    active boolean not null default true,
    updated_at timestamp with time zone not null default (now() at time zone 'utc'::text),
    created_at timestamp with time zone not null default (now() at time zone 'utc'::text),
    department public.roles_dept null default 'na'::roles_dept,
    other_roles roles_pos[] null,
    constraint users_pkey primary key (id),
    constraint users_email_key unique (email),
    constraint users_id_key unique (id)
  ) tablespace pg_default;

create index if not exists users_role_idx on public.users using btree (role) tablespace pg_default;


create table
  public.users (
    id uuid not null default auth.uid (),
    email text not null,
    name text not null default 'Unverified User'::text,
    avatar_url text null default ''::text,
    role public.roles_user null default 'student'::roles_user,
    active boolean not null default true,
    updated_at timestamp with time zone not null default (now() at time zone 'utc'::text),
    created_at timestamp with time zone not null default (now() at time zone 'utc'::text),
    department public.roles_dept null default 'na'::roles_dept,
    other_roles roles_pos[] null,
    constraint users_pkey primary key (id),
    constraint users_email_key unique (email),
    constraint users_id_key unique (id)
  ) tablespace pg_default;

create index if not exists users_role_idx on public.users using btree (role) tablespace pg_default;

create trigger delete_user_from_auth
after delete on users for each row
execute function remove_user_from_auth ();

create trigger handle_updated_at before
update on users for each row
execute function extensions.moddatetime ('updated_at');

create trigger update_raw_app_meta_data_trigger
after
update of role,
active on users for each row when (
  old.role is distinct from new.role
  or old.active is distinct from new.active
)
execute function update_raw_app_meta_data ();

-- Supabase AI is experimental and may produce incorrect answers
-- Always verify the output before executing
CREATE
OR REPLACE FUNCTION public.handle_new_user () RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER
SET
  search_path = '' AS $$
BEGIN
    RAISE LOG 'Role: %, Dept: %, Pos: %',
    NEW.raw_user_meta_data ->> 'role',
    NEW.raw_user_meta_data ->> 'dept',
    NEW.raw_user_meta_data ->> 'pos';

    INSERT INTO public.users (
        id,
        email,
        name,
        avatar_url,
        active,
        role,
        department,
        other_roles
    ) VALUES (
        NEW.id,
        NEW.email,
        NEW.raw_user_meta_data ->> 'name',
        NEW.raw_user_meta_data ->> 'avatar_url',
        TRUE,
        (NEW.raw_user_meta_data ->> 'role')::public.roles_user,
        (NEW.raw_user_meta_data ->> 'dept')::public.roles_dept,
       CASE
            WHEN NEW.raw_user_meta_data -> 'pos' IS NULL
                 OR NEW.raw_user_meta_data -> 'pos' = '[]' THEN ARRAY[]::public.roles_pos[]
            ELSE (SELECT ARRAY(SELECT elem::public.roles_pos
                               FROM jsonb_array_elements_text(NEW.raw_user_meta_data -> 'pos') AS elem))
        END
    );

    RETURN NEW;
END;
$$;

create table
  public.activity_files (
    id uuid not null default gen_random_uuid (),
    name text not null default ''::text,
    checksum text not null default ''::text,
    activity uuid not null default gen_random_uuid (),
    uploaded_at timestamp with time zone not null default (now() at time zone 'utc'::text),
    type text not null default '???'::text,
    key text null,
    encrypted_checksum text null,
    constraint event_files_pkey primary key (id),
    constraint activity_files_key_key unique (key),
    constraint activity_files_mac_key unique (encrypted_checksum),
    constraint event_files_event_fkey foreign key (activity) references activities (id) on update cascade on delete cascade
  ) tablespace pg_default;

create index if not exists activity_files_checksum_idx on public.activity_files using btree (checksum, encrypted_checksum) tablespace pg_default;

create trigger update_raw_app_meta_data_trigger
after
update
    of role,
    active on users for each row
    when (
        old.role is distinct
        from
            new.role
            or old.active is distinct
        from
            new.active
    ) execute function update_raw_app_meta_data ();

-- VIEWS
create view
  public.activities_details_view
  with (security_invoker = on)
  as
select
  activities.id,
  activities.title,
  activities.description,
  series.title as series,
  series.color as series_color,
  activities.visibility,
  activities.image_url,
  activities.date_starting,
  activities.date_ending,
  activities.created_at,
  activities.updated_at,
  activities.feedback,
  activities.objectives,
  activities.outcomes,
  users.name as created_by,
  users.email as creator_email,
  users.role as creator_role,
  users.department as creator_department,
  users.other_roles as creator_other_roles,
  users.avatar_url as creator_avatar
from
  activities
  left join users on activities.created_by = users.id
  left join series on activities.series = series.id;

    create view
      public.activities_faculties_view
      with (security_invoker = on)
      as
    select
      activities.id as activity_id,
      users.id,
      users.email,
      users.name,
      users.avatar_url,
      users.role,
      users.active,
      users.department,
      users.other_roles,
      ref.id as referrer_id,
      ref.email as referrer_email,
      ref.name as referrer_name,
      ref.avatar_url as referrer_avatar,
      ref.role as referrer_role,
      ref.department as referrer_department,
      ref.other_roles as referrer_other_roles
    from
      faculty_assignments
      left join activities on activities.id = faculty_assignments.activity_id
      left join users on users.id = faculty_assignments.user_id
      left join users ref on ref.id = faculty_assignments.referrer;

create view
    public.activities_subscriptions_view
    with (security_invoker = on)
    as
select
    activities.id as activity_id,
    users.id as subscriber_id,
    users.name as subscriber_name,
    users.email as subscriber_email,
    users.avatar_url as subscriber_avatar
from
    activity_subscriptions
    left join activities on activities.id = activity_subscriptions.activity_id
    left join users on users.id = activity_subscriptions.user_id;


    create table
      public.activity_feedback (
        id uuid not null default gen_random_uuid (),
        activity_id uuid not null,
        response jsonb not null,
        submitted_at timestamp with time zone not null default (now() at time zone 'utc'::text),
        user_id uuid null default auth.uid (),
        type public.feedback_type not null,
        score_emotions jsonb null,
        score_sentiment jsonb null,
        score_ratings smallint null,
        constraint activity_feedback_pkey primary key (id),
        constraint activity_feedback_activity_id_fkey foreign key (activity_id) references activities (id) on update cascade on delete cascade,
        constraint activity_feedback_user_id_fkey foreign key (user_id) references users (id) on update cascade on delete set null
      ) tablespace pg_default;

    create index if not exists activity_feedback_type_activity_id_idx on public.activity_feedback using btree (
      type,
      activity_id
    ) tablespace pg_default;

    create index if not exists activity_feedback_score_sentiment_score_emotions_response_idx on public.activity_feedback using gin (score_sentiment, score_emotions, response) tablespace pg_default;

    create view
      public.activity_feedback_view as
    select
      activity_feedback.activity_id,
      activity_feedback.type,
      jsonb_agg(activity_feedback.score_emotions) as score_emotions,
      jsonb_agg(activity_feedback.score_sentiment) as score_sentiment,
      sum(activity_feedback.score_ratings) as score_ratings,
      case
        when activity_feedback.type = 'partners'::feedback_type then 78 * count(activity_feedback.type)
        when activity_feedback.type = 'implementers'::feedback_type then 102 * count(activity_feedback.type)
        when activity_feedback.type = 'beneficiaries'::feedback_type then 48 * count(activity_feedback.type)
        else 0::bigint
      end as max_ratings
    from
      activity_feedback
    group by
      activity_feedback.activity_id,
      activity_feedback.type;

    CREATE FUNCTION public.delete_linked_activity_data () RETURNS TRIGGER AS $$
    BEGIN
        -- Delete from activity_subscriptions
        DELETE FROM public.activity_subscriptions
        WHERE activity_id = OLD.id;

        -- Delete from faculty_assignments
        DELETE FROM public.faculty_assignments
        WHERE activity_id = OLD.id;

        -- Delete from activity_files
        DELETE FROM public.activity_files
        WHERE activity = OLD.id;

        RETURN OLD;
    END;
    $$ LANGUAGE plpgsql;


    -- this trigger will set the "updated_at" column to the current timestamp for every update
    create extension if not exists moddatetime schema extensions;
    create trigger
      handle_updated_at before update
    on public.activity_files
    for each row execute
      procedure moddatetime(updated_at);

      create trigger
        handle_updated_at before update
      on public.users
      for each row execute
        procedure moddatetime(updated_at);

      create trigger
        handle_updated_at before update
      on public.activities
      for each row execute
        procedure moddatetime(updated_at);
