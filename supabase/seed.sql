-- TABLES
create table public.allowed_domains (
    domain text not null,
    constraint allowed_domains_pkey primary key (domain),
    constraint allowed_domains_domain_key unique (domain)
) tablespace pg_default;

create table public.events (
    id uuid not null default gen_random_uuid (),
    title text not null,
    description text null,
    visibility public.event_visibility not null default 'Everyone' :: event_visibility,
    date_starting timestamp with time zone null,
    date_ending timestamp with time zone null,
    created_at timestamp with time zone not null default (now() at time zone 'utc' :: text),
    updated_at timestamp with time zone null default (now() at time zone 'utc' :: text),
    created_by uuid not null default auth.uid (),
    series uuid null,
    image_url text null,
    constraint events_pkey primary key (id),
    constraint events_title_key unique (title),
    constraint events_created_by_fkey foreign key (created_by) references users (id) on update cascade on delete
    set
        null,
        constraint events_series_fkey foreign key (series) references series (id) on update cascade on delete
    set
        null
) tablespace pg_default;

create table public.faculty_assignments (
    id bigint generated by default as identity not null,
    event_id uuid null,
    user_id uuid null,
    created_at timestamp with time zone not null default now(),
    constraint event_handlers_pkey primary key (id),
    constraint event_handlers_id_key unique (id),
    constraint event_handlers_event_id_fkey foreign key (event_id) references events (id) on update cascade on delete cascade,
    constraint event_handlers_user_id_fkey foreign key (user_id) references users (id) on update cascade on delete cascade
) tablespace pg_default;

-- for upserting data
create unique index if not exists faculty_assignments_event_id_user_id_idx on public.faculty_assignments using btree (event_id, user_id) tablespace pg_default;

create table public.series (
    id uuid not null default gen_random_uuid (),
    title text not null,
    created_at timestamp with time zone not null default now(),
    color text null,
    constraint series_pkey primary key (id),
    constraint event_groups_title_key unique (title),
    constraint series_color_check check ((length(color) <= 10))
) tablespace pg_default;

create table public.users (
    id uuid not null default auth.uid (),
    email text not null,
    name text not null,
    avatar_url text null default '' :: text,
    role public.roles_user null,
    active boolean not null default true,
    updated_at timestamp with time zone not null default (now() at time zone 'utc' :: text),
    created_at timestamp with time zone not null default (now() at time zone 'utc' :: text),
    department public.roles_dept not null default 'na' :: roles_dept,
    other_roles roles_pos [] null,
    constraint users_pkey primary key (id),
    constraint users_email_key unique (email),
    constraint users_id_key unique (id)
) tablespace pg_default;

create table public.event_files (
    id uuid not null default gen_random_uuid (),
    name text not null default '' :: text,
    checksum text not null default '' :: text,
    event uuid not null default gen_random_uuid (),
    uploaded_at timestamp with time zone not null default (now() at time zone 'utc' :: text),
    type text not null default '???' :: text,
    constraint event_files_pkey primary key (id),
    constraint event_files_event_fkey foreign key (event) references events (id) on update cascade on delete cascade
) tablespace pg_default;

create trigger update_raw_app_meta_data_trigger
after
update
    of role,
    active on users for each row
    when (
        old.role is distinct
        from
            new.role
            or old.active is distinct
        from
            new.active
    ) execute function update_raw_app_meta_data ();

-- VIEWS
create view public.events_details_view with (security_invoker = on) as
select
    events.id,
    events.title,
    events.description,
    series.title as series,
    series.color as series_color,
    events.visibility,
    events.image_url,
    events.date_starting,
    events.date_ending,
    events.created_at,
    events.updated_at,
    users.name as created_by,
    users.email as creator_email,
    users.avatar_url as creator_avatar
from
    events
    left join users on events.created_by = users.id
    left join series on events.series = series.id;

create view public.events_faculties_view as
select
    events.id as event_id,
    users.id as faculty_id,
    users.name as faculty_name,
    users.email as faculty_email,
    users.avatar_url as faculty_avatar
from
    faculty_assignments
    left join events on events.id = faculty_assignments.event_id
    left join users on users.id = faculty_assignments.user_id;