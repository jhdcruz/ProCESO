create extension if not exists "hypopg" with schema "extensions";

create extension if not exists "index_advisor" with schema "extensions";

create extension if not exists "intarray" with schema "extensions";

create extension if not exists "moddatetime" with schema "extensions";

create extension if not exists "postgis" with schema "extensions";


create type "public"."activity_visibility" as enum ('Everyone', 'Faculty', 'Internal');

create type "public"."feedback_type" as enum ('partners', 'implementers', 'beneficiaries');

create type "public"."roles_dept" as enum ('ccs', 'cea', 'cbe', 'coa', 'ceso', 'na', 'itso');

create type "public"."roles_pos" as enum ('head', 'dean', 'chair');

create type "public"."roles_user" as enum ('admin', 'staff', 'faculty', 'officer', 'student');

create table "public"."activities" (
    "id" uuid not null default gen_random_uuid(),
    "title" text not null,
    "description" text,
    "visibility" activity_visibility not null default 'Everyone'::activity_visibility,
    "date_starting" timestamp with time zone,
    "date_ending" timestamp with time zone,
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "updated_at" timestamp with time zone default (now() AT TIME ZONE 'utc'::text),
    "created_by" uuid not null default auth.uid(),
    "series" uuid,
    "image_url" text,
    "objectives" text[] not null default '{}'::text[],
    "feedback" boolean not null default false,
    "outcomes" text[] not null default '{"''Key Outcomes''","''Impact on Community''","''Success Indicators''","''Overall Achievement Level''"}'::text[],
    "venue_additional" text,
    "venue" numeric[]
);


alter table "public"."activities" enable row level security;

create table "public"."activity_feedback" (
    "id" uuid not null default gen_random_uuid(),
    "activity_id" uuid not null,
    "response" jsonb not null,
    "submitted_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "user_id" uuid default auth.uid(),
    "type" feedback_type not null,
    "score_emotions" jsonb,
    "score_sentiment" jsonb,
    "score_ratings" smallint
);


alter table "public"."activity_feedback" enable row level security;

create table "public"."activity_files" (
    "id" uuid not null default gen_random_uuid(),
    "name" text not null default ''::text,
    "checksum" text not null default ''::text,
    "activity" uuid not null default gen_random_uuid(),
    "uploaded_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "type" text not null default '???'::text,
    "key" text,
    "encrypted_checksum" text
);


alter table "public"."activity_files" enable row level security;

create table "public"."activity_subscriptions" (
    "id" uuid not null default gen_random_uuid(),
    "activity_id" uuid not null,
    "user_id" uuid not null,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."activity_subscriptions" enable row level security;

create table "public"."allowed_domains" (
    "domain" text not null
);


alter table "public"."allowed_domains" enable row level security;

create table "public"."analytics_metadata" (
    "id" bigint generated by default as identity not null,
    "activity_id" uuid not null,
    "type" text not null,
    "updated_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "content" text
);


alter table "public"."analytics_metadata" enable row level security;

create table "public"."certs" (
    "id" uuid not null default gen_random_uuid(),
    "recipient_name" text,
    "recipient_email" text,
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "generated_by" uuid default auth.uid(),
    "hash" text,
    "activity_id" uuid,
    "url" text
);


alter table "public"."certs" enable row level security;

create table "public"."faculty_assignments" (
    "id" bigint generated by default as identity not null,
    "activity_id" uuid,
    "user_id" uuid,
    "created_at" timestamp with time zone not null default now(),
    "referrer" uuid default auth.uid(),
    "rsvp" boolean
);


alter table "public"."faculty_assignments" enable row level security;

create table "public"."series" (
    "id" uuid not null default gen_random_uuid(),
    "title" text not null,
    "created_at" timestamp with time zone not null default now(),
    "color" text
);


alter table "public"."series" enable row level security;

create table "public"."users" (
    "id" uuid not null default auth.uid(),
    "email" text not null,
    "name" text default 'Unverified User'::text,
    "avatar_url" text default ''::text,
    "role" roles_user default 'student'::roles_user,
    "active" boolean not null default true,
    "updated_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "department" roles_dept default 'na'::roles_dept,
    "other_roles" roles_pos[]
);


alter table "public"."users" enable row level security;

CREATE INDEX activities_date_starting_date_ending_idx ON public.activities USING btree (date_starting, date_ending);

CREATE UNIQUE INDEX activity_feedback_pkey ON public.activity_feedback USING btree (id);

CREATE INDEX activity_feedback_score_sentiment_score_emotions_response_idx ON public.activity_feedback USING gin (score_sentiment, score_emotions, response);

CREATE INDEX activity_feedback_type_activity_id_idx ON public.activity_feedback USING btree (type, activity_id);

CREATE UNIQUE INDEX activity_files_checksum_activity_idx ON public.activity_files USING btree (activity, checksum);

CREATE INDEX activity_files_checksum_idx ON public.activity_files USING btree (checksum);

CREATE UNIQUE INDEX activity_files_key_key ON public.activity_files USING btree (key);

CREATE UNIQUE INDEX activity_files_mac_key ON public.activity_files USING btree (encrypted_checksum);

CREATE UNIQUE INDEX allowed_domains_domain_key ON public.allowed_domains USING btree (domain);

CREATE UNIQUE INDEX allowed_domains_pkey ON public.allowed_domains USING btree (domain);

CREATE UNIQUE INDEX analytics_metadata_pkey ON public.analytics_metadata USING btree (id);

CREATE UNIQUE INDEX analytics_metadata_type_idx ON public.analytics_metadata USING btree (activity_id, type);

CREATE UNIQUE INDEX certs_pkey ON public.certs USING btree (id);

CREATE UNIQUE INDEX event_files_pkey ON public.activity_files USING btree (id);

CREATE UNIQUE INDEX event_groups_title_key ON public.series USING btree (title);

CREATE UNIQUE INDEX event_handlers_id_key ON public.faculty_assignments USING btree (id);

CREATE UNIQUE INDEX event_handlers_pkey ON public.faculty_assignments USING btree (id);

CREATE UNIQUE INDEX event_subscription_event_id_user_id_idx ON public.activity_subscriptions USING btree (activity_id, user_id);

CREATE UNIQUE INDEX events_pkey ON public.activities USING btree (id);

CREATE UNIQUE INDEX events_title_key ON public.activities USING btree (title);

CREATE UNIQUE INDEX faculty_assignments_event_id_user_id_idx ON public.faculty_assignments USING btree (activity_id, user_id);

CREATE UNIQUE INDEX participants_pkey ON public.activity_subscriptions USING btree (id);

CREATE UNIQUE INDEX series_pkey ON public.series USING btree (id);

CREATE UNIQUE INDEX users_email_key ON public.users USING btree (email);

CREATE UNIQUE INDEX users_id_key ON public.users USING btree (id);

CREATE UNIQUE INDEX users_pkey ON public.users USING btree (id);

CREATE INDEX users_role_idx ON public.users USING btree (role);

alter table "public"."activities" add constraint "events_pkey" PRIMARY KEY using index "events_pkey";

alter table "public"."activity_feedback" add constraint "activity_feedback_pkey" PRIMARY KEY using index "activity_feedback_pkey";

alter table "public"."activity_files" add constraint "event_files_pkey" PRIMARY KEY using index "event_files_pkey";

alter table "public"."activity_subscriptions" add constraint "participants_pkey" PRIMARY KEY using index "participants_pkey";

alter table "public"."allowed_domains" add constraint "allowed_domains_pkey" PRIMARY KEY using index "allowed_domains_pkey";

alter table "public"."analytics_metadata" add constraint "analytics_metadata_pkey" PRIMARY KEY using index "analytics_metadata_pkey";

alter table "public"."certs" add constraint "certs_pkey" PRIMARY KEY using index "certs_pkey";

alter table "public"."faculty_assignments" add constraint "event_handlers_pkey" PRIMARY KEY using index "event_handlers_pkey";

alter table "public"."series" add constraint "series_pkey" PRIMARY KEY using index "series_pkey";

alter table "public"."users" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."activities" add constraint "events_created_by_fkey" FOREIGN KEY (created_by) REFERENCES users(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."activities" validate constraint "events_created_by_fkey";

alter table "public"."activities" add constraint "events_series_fkey" FOREIGN KEY (series) REFERENCES series(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."activities" validate constraint "events_series_fkey";

alter table "public"."activities" add constraint "events_title_key" UNIQUE using index "events_title_key";

alter table "public"."activity_feedback" add constraint "activity_feedback_activity_id_fkey" FOREIGN KEY (activity_id) REFERENCES activities(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."activity_feedback" validate constraint "activity_feedback_activity_id_fkey";

alter table "public"."activity_feedback" add constraint "activity_feedback_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."activity_feedback" validate constraint "activity_feedback_user_id_fkey";

alter table "public"."activity_files" add constraint "activity_files_key_key" UNIQUE using index "activity_files_key_key";

alter table "public"."activity_files" add constraint "activity_files_mac_key" UNIQUE using index "activity_files_mac_key";

alter table "public"."activity_files" add constraint "event_files_event_fkey" FOREIGN KEY (activity) REFERENCES activities(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."activity_files" validate constraint "event_files_event_fkey";

alter table "public"."activity_subscriptions" add constraint "participants_event_id_fkey" FOREIGN KEY (activity_id) REFERENCES activities(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."activity_subscriptions" validate constraint "participants_event_id_fkey";

alter table "public"."activity_subscriptions" add constraint "participants_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."activity_subscriptions" validate constraint "participants_user_id_fkey";

alter table "public"."allowed_domains" add constraint "allowed_domains_domain_key" UNIQUE using index "allowed_domains_domain_key";

alter table "public"."analytics_metadata" add constraint "analytics_metadata_activity_id_fkey" FOREIGN KEY (activity_id) REFERENCES activities(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."analytics_metadata" validate constraint "analytics_metadata_activity_id_fkey";

alter table "public"."certs" add constraint "certs_activity_id_fkey" FOREIGN KEY (activity_id) REFERENCES activities(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."certs" validate constraint "certs_activity_id_fkey";

alter table "public"."certs" add constraint "certs_generated_by_fkey" FOREIGN KEY (generated_by) REFERENCES users(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."certs" validate constraint "certs_generated_by_fkey";

alter table "public"."faculty_assignments" add constraint "event_handlers_event_id_fkey" FOREIGN KEY (activity_id) REFERENCES activities(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."faculty_assignments" validate constraint "event_handlers_event_id_fkey";

alter table "public"."faculty_assignments" add constraint "event_handlers_id_key" UNIQUE using index "event_handlers_id_key";

alter table "public"."faculty_assignments" add constraint "event_handlers_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."faculty_assignments" validate constraint "event_handlers_user_id_fkey";

alter table "public"."faculty_assignments" add constraint "faculty_assignments_referrer_fkey" FOREIGN KEY (referrer) REFERENCES users(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."faculty_assignments" validate constraint "faculty_assignments_referrer_fkey";

alter table "public"."series" add constraint "event_groups_title_key" UNIQUE using index "event_groups_title_key";

alter table "public"."series" add constraint "series_color_check" CHECK ((length(color) <= 10)) not valid;

alter table "public"."series" validate constraint "series_color_check";

alter table "public"."users" add constraint "users_email_key" UNIQUE using index "users_email_key";

alter table "public"."users" add constraint "users_id_key" UNIQUE using index "users_id_key";

set check_function_bodies = off;

create or replace view "public"."activities_details_view" as  SELECT activities.id,
    activities.title,
    activities.description,
    activities.venue,
    activities.venue_additional,
    series.title AS series,
    series.color AS series_color,
    activities.visibility,
    activities.image_url,
    activities.date_starting,
    activities.date_ending,
    activities.created_at,
    activities.updated_at,
    activities.feedback,
    activities.objectives,
    activities.outcomes,
    users.name AS created_by,
    users.email AS creator_email,
    users.role AS creator_role,
    users.department AS creator_department,
    users.other_roles AS creator_other_roles,
    users.avatar_url AS creator_avatar
   FROM ((activities
     LEFT JOIN users ON ((activities.created_by = users.id)))
     LEFT JOIN series ON ((activities.series = series.id)));


create or replace view "public"."activities_faculties_view" as  SELECT activities.id AS activity_id,
    users.id,
    users.email,
    users.name,
    users.avatar_url,
    users.role,
    users.active,
    users.department,
    users.other_roles,
    faculty_assignments.rsvp,
    ref.id AS referrer_id,
    ref.email AS referrer_email,
    ref.name AS referrer_name,
    ref.avatar_url AS referrer_avatar,
    ref.role AS referrer_role,
    ref.department AS referrer_department,
    ref.other_roles AS referrer_other_roles
   FROM (((faculty_assignments
     LEFT JOIN activities ON ((activities.id = faculty_assignments.activity_id)))
     LEFT JOIN users ON ((users.id = faculty_assignments.user_id)))
     LEFT JOIN users ref ON ((ref.id = faculty_assignments.referrer)));


create or replace view "public"."activities_subscriptions_view" as  SELECT activities.id AS activity_id,
    users.id AS subscriber_id,
    users.name AS subscriber_name,
    users.email AS subscriber_email,
    users.avatar_url AS subscriber_avatar
   FROM ((activity_subscriptions
     LEFT JOIN activities ON ((activities.id = activity_subscriptions.activity_id)))
     LEFT JOIN users ON ((users.id = activity_subscriptions.user_id)));


create or replace view "public"."activity_eval_view" as  SELECT activities.title,
    activity_feedback.type,
    ((activity_feedback.response -> 'respondent'::text) ->> 'name'::text) AS name,
    ((activity_feedback.response -> 'respondent'::text) ->> 'email'::text) AS email,
    ((activity_feedback.score_sentiment ->> 'positive'::text))::double precision AS sentiment_positive,
    ((activity_feedback.score_sentiment ->> 'neutral'::text))::double precision AS sentiment_neutral,
    ((activity_feedback.score_sentiment ->> 'negative'::text))::double precision AS sentiment_negative,
    activity_feedback.score_ratings AS rating_score,
        CASE
            WHEN (activity_feedback.type = 'partners'::feedback_type) THEN (72)::bigint
            WHEN (activity_feedback.type = 'implementers'::feedback_type) THEN (102)::bigint
            WHEN (activity_feedback.type = 'beneficiaries'::feedback_type) THEN (48)::bigint
            ELSE (0)::bigint
        END AS rating_max,
    string_agg((emotions.value ->> 'label'::text), ' '::text) AS emotion_labels,
    activity_feedback.submitted_at
   FROM (activity_feedback
     LEFT JOIN activities ON ((activity_feedback.activity_id = activities.id))),
    LATERAL jsonb_array_elements((activity_feedback.score_emotions -> 'emotions'::text)) emotions(value)
  GROUP BY activities.title, activity_feedback.type, activity_feedback.response, activity_feedback.score_sentiment, activity_feedback.score_ratings, activity_feedback.submitted_at;


create or replace view "public"."activity_feedback_view" as  SELECT activity_feedback.activity_id,
    activity_feedback.type,
    jsonb_agg(activity_feedback.score_emotions) AS score_emotions,
    jsonb_agg(activity_feedback.score_sentiment) AS score_sentiment,
    sum(activity_feedback.score_ratings) AS score_ratings,
        CASE
            WHEN (activity_feedback.type = 'partners'::feedback_type) THEN (72 * count(activity_feedback.type))
            WHEN (activity_feedback.type = 'implementers'::feedback_type) THEN (102 * count(activity_feedback.type))
            WHEN (activity_feedback.type = 'beneficiaries'::feedback_type) THEN (48 * count(activity_feedback.type))
            ELSE (0)::bigint
        END AS max_ratings
   FROM activity_feedback
  GROUP BY activity_feedback.activity_id, activity_feedback.type;


CREATE OR REPLACE FUNCTION public.delete_linked_activity_data()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Delete from activity_subscriptions
    DELETE FROM public.activity_subscriptions
    WHERE activity_id = OLD.id;

    -- Delete from faculty_assignments
    DELETE FROM public.faculty_assignments
    WHERE activity_id = OLD.id;

    -- Delete from activity_files
    DELETE FROM public.activity_files
    WHERE activity = OLD.id;

    RETURN OLD;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$BEGIN
    RAISE LOG 'Role: %, Dept: %, Pos: %',
    NEW.raw_user_meta_data ->> 'role',
    NEW.raw_user_meta_data ->> 'dept',
    NEW.raw_user_meta_data ->> 'pos';

    INSERT INTO public.users (
        id,
        email,
        name,
        avatar_url,
        active,
        role,
        department,
        other_roles
    ) VALUES (
        NEW.id,
        NEW.email,
        NEW.raw_user_meta_data ->> 'name',
        NEW.raw_user_meta_data ->> 'avatar_url',
        TRUE,
        (NEW.raw_user_meta_data ->> 'role')::public.roles_user,
        (NEW.raw_user_meta_data ->> 'dept')::public.roles_dept,
       CASE 
            WHEN NEW.raw_user_meta_data -> 'pos' IS NULL 
                 OR NEW.raw_user_meta_data -> 'pos' = '[]' THEN ARRAY[]::public.roles_pos[]
            ELSE (SELECT ARRAY(SELECT elem::public.roles_pos 
                               FROM jsonb_array_elements_text(NEW.raw_user_meta_data -> 'pos') AS elem))
        END
    );

    RETURN NEW;
END;$function$
;

CREATE OR REPLACE FUNCTION public.update_raw_app_meta_data()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
BEGIN
    IF OLD.role IS DISTINCT FROM NEW.role THEN
        UPDATE auth.users
        SET raw_app_meta_data = jsonb_set(raw_app_meta_data, '{role}', to_jsonb(NEW.role::text))
        WHERE id = NEW.id;
    END IF;

    IF OLD.active IS DISTINCT FROM NEW.active THEN
        UPDATE auth.users
        SET raw_app_meta_data = jsonb_set(raw_app_meta_data, '{active}', to_jsonb(NEW.active::boolean))
        WHERE id = NEW.id;
    END IF;
    RETURN NEW;
END;
$function$
;

grant delete on table "public"."activities" to "anon";

grant insert on table "public"."activities" to "anon";

grant references on table "public"."activities" to "anon";

grant select on table "public"."activities" to "anon";

grant trigger on table "public"."activities" to "anon";

grant truncate on table "public"."activities" to "anon";

grant update on table "public"."activities" to "anon";

grant delete on table "public"."activities" to "authenticated";

grant insert on table "public"."activities" to "authenticated";

grant references on table "public"."activities" to "authenticated";

grant select on table "public"."activities" to "authenticated";

grant trigger on table "public"."activities" to "authenticated";

grant truncate on table "public"."activities" to "authenticated";

grant update on table "public"."activities" to "authenticated";

grant delete on table "public"."activities" to "service_role";

grant insert on table "public"."activities" to "service_role";

grant references on table "public"."activities" to "service_role";

grant select on table "public"."activities" to "service_role";

grant trigger on table "public"."activities" to "service_role";

grant truncate on table "public"."activities" to "service_role";

grant update on table "public"."activities" to "service_role";

grant delete on table "public"."activity_feedback" to "anon";

grant insert on table "public"."activity_feedback" to "anon";

grant references on table "public"."activity_feedback" to "anon";

grant select on table "public"."activity_feedback" to "anon";

grant trigger on table "public"."activity_feedback" to "anon";

grant truncate on table "public"."activity_feedback" to "anon";

grant update on table "public"."activity_feedback" to "anon";

grant delete on table "public"."activity_feedback" to "authenticated";

grant insert on table "public"."activity_feedback" to "authenticated";

grant references on table "public"."activity_feedback" to "authenticated";

grant select on table "public"."activity_feedback" to "authenticated";

grant trigger on table "public"."activity_feedback" to "authenticated";

grant truncate on table "public"."activity_feedback" to "authenticated";

grant update on table "public"."activity_feedback" to "authenticated";

grant delete on table "public"."activity_feedback" to "service_role";

grant insert on table "public"."activity_feedback" to "service_role";

grant references on table "public"."activity_feedback" to "service_role";

grant select on table "public"."activity_feedback" to "service_role";

grant trigger on table "public"."activity_feedback" to "service_role";

grant truncate on table "public"."activity_feedback" to "service_role";

grant update on table "public"."activity_feedback" to "service_role";

grant delete on table "public"."activity_files" to "anon";

grant insert on table "public"."activity_files" to "anon";

grant references on table "public"."activity_files" to "anon";

grant select on table "public"."activity_files" to "anon";

grant trigger on table "public"."activity_files" to "anon";

grant truncate on table "public"."activity_files" to "anon";

grant update on table "public"."activity_files" to "anon";

grant delete on table "public"."activity_files" to "authenticated";

grant insert on table "public"."activity_files" to "authenticated";

grant references on table "public"."activity_files" to "authenticated";

grant select on table "public"."activity_files" to "authenticated";

grant trigger on table "public"."activity_files" to "authenticated";

grant truncate on table "public"."activity_files" to "authenticated";

grant update on table "public"."activity_files" to "authenticated";

grant delete on table "public"."activity_files" to "service_role";

grant insert on table "public"."activity_files" to "service_role";

grant references on table "public"."activity_files" to "service_role";

grant select on table "public"."activity_files" to "service_role";

grant trigger on table "public"."activity_files" to "service_role";

grant truncate on table "public"."activity_files" to "service_role";

grant update on table "public"."activity_files" to "service_role";

grant delete on table "public"."activity_subscriptions" to "anon";

grant insert on table "public"."activity_subscriptions" to "anon";

grant references on table "public"."activity_subscriptions" to "anon";

grant select on table "public"."activity_subscriptions" to "anon";

grant trigger on table "public"."activity_subscriptions" to "anon";

grant truncate on table "public"."activity_subscriptions" to "anon";

grant update on table "public"."activity_subscriptions" to "anon";

grant delete on table "public"."activity_subscriptions" to "authenticated";

grant insert on table "public"."activity_subscriptions" to "authenticated";

grant references on table "public"."activity_subscriptions" to "authenticated";

grant select on table "public"."activity_subscriptions" to "authenticated";

grant trigger on table "public"."activity_subscriptions" to "authenticated";

grant truncate on table "public"."activity_subscriptions" to "authenticated";

grant update on table "public"."activity_subscriptions" to "authenticated";

grant delete on table "public"."activity_subscriptions" to "service_role";

grant insert on table "public"."activity_subscriptions" to "service_role";

grant references on table "public"."activity_subscriptions" to "service_role";

grant select on table "public"."activity_subscriptions" to "service_role";

grant trigger on table "public"."activity_subscriptions" to "service_role";

grant truncate on table "public"."activity_subscriptions" to "service_role";

grant update on table "public"."activity_subscriptions" to "service_role";

grant delete on table "public"."allowed_domains" to "anon";

grant insert on table "public"."allowed_domains" to "anon";

grant references on table "public"."allowed_domains" to "anon";

grant select on table "public"."allowed_domains" to "anon";

grant trigger on table "public"."allowed_domains" to "anon";

grant truncate on table "public"."allowed_domains" to "anon";

grant update on table "public"."allowed_domains" to "anon";

grant delete on table "public"."allowed_domains" to "authenticated";

grant insert on table "public"."allowed_domains" to "authenticated";

grant references on table "public"."allowed_domains" to "authenticated";

grant select on table "public"."allowed_domains" to "authenticated";

grant trigger on table "public"."allowed_domains" to "authenticated";

grant truncate on table "public"."allowed_domains" to "authenticated";

grant update on table "public"."allowed_domains" to "authenticated";

grant delete on table "public"."allowed_domains" to "service_role";

grant insert on table "public"."allowed_domains" to "service_role";

grant references on table "public"."allowed_domains" to "service_role";

grant select on table "public"."allowed_domains" to "service_role";

grant trigger on table "public"."allowed_domains" to "service_role";

grant truncate on table "public"."allowed_domains" to "service_role";

grant update on table "public"."allowed_domains" to "service_role";

grant delete on table "public"."analytics_metadata" to "anon";

grant insert on table "public"."analytics_metadata" to "anon";

grant references on table "public"."analytics_metadata" to "anon";

grant select on table "public"."analytics_metadata" to "anon";

grant trigger on table "public"."analytics_metadata" to "anon";

grant truncate on table "public"."analytics_metadata" to "anon";

grant update on table "public"."analytics_metadata" to "anon";

grant delete on table "public"."analytics_metadata" to "authenticated";

grant insert on table "public"."analytics_metadata" to "authenticated";

grant references on table "public"."analytics_metadata" to "authenticated";

grant select on table "public"."analytics_metadata" to "authenticated";

grant trigger on table "public"."analytics_metadata" to "authenticated";

grant truncate on table "public"."analytics_metadata" to "authenticated";

grant update on table "public"."analytics_metadata" to "authenticated";

grant delete on table "public"."analytics_metadata" to "service_role";

grant insert on table "public"."analytics_metadata" to "service_role";

grant references on table "public"."analytics_metadata" to "service_role";

grant select on table "public"."analytics_metadata" to "service_role";

grant trigger on table "public"."analytics_metadata" to "service_role";

grant truncate on table "public"."analytics_metadata" to "service_role";

grant update on table "public"."analytics_metadata" to "service_role";

grant delete on table "public"."certs" to "anon";

grant insert on table "public"."certs" to "anon";

grant references on table "public"."certs" to "anon";

grant select on table "public"."certs" to "anon";

grant trigger on table "public"."certs" to "anon";

grant truncate on table "public"."certs" to "anon";

grant update on table "public"."certs" to "anon";

grant delete on table "public"."certs" to "authenticated";

grant insert on table "public"."certs" to "authenticated";

grant references on table "public"."certs" to "authenticated";

grant select on table "public"."certs" to "authenticated";

grant trigger on table "public"."certs" to "authenticated";

grant truncate on table "public"."certs" to "authenticated";

grant update on table "public"."certs" to "authenticated";

grant delete on table "public"."certs" to "service_role";

grant insert on table "public"."certs" to "service_role";

grant references on table "public"."certs" to "service_role";

grant select on table "public"."certs" to "service_role";

grant trigger on table "public"."certs" to "service_role";

grant truncate on table "public"."certs" to "service_role";

grant update on table "public"."certs" to "service_role";

grant delete on table "public"."faculty_assignments" to "anon";

grant insert on table "public"."faculty_assignments" to "anon";

grant references on table "public"."faculty_assignments" to "anon";

grant select on table "public"."faculty_assignments" to "anon";

grant trigger on table "public"."faculty_assignments" to "anon";

grant truncate on table "public"."faculty_assignments" to "anon";

grant update on table "public"."faculty_assignments" to "anon";

grant delete on table "public"."faculty_assignments" to "authenticated";

grant insert on table "public"."faculty_assignments" to "authenticated";

grant references on table "public"."faculty_assignments" to "authenticated";

grant select on table "public"."faculty_assignments" to "authenticated";

grant trigger on table "public"."faculty_assignments" to "authenticated";

grant truncate on table "public"."faculty_assignments" to "authenticated";

grant update on table "public"."faculty_assignments" to "authenticated";

grant delete on table "public"."faculty_assignments" to "service_role";

grant insert on table "public"."faculty_assignments" to "service_role";

grant references on table "public"."faculty_assignments" to "service_role";

grant select on table "public"."faculty_assignments" to "service_role";

grant trigger on table "public"."faculty_assignments" to "service_role";

grant truncate on table "public"."faculty_assignments" to "service_role";

grant update on table "public"."faculty_assignments" to "service_role";

grant delete on table "public"."series" to "anon";

grant insert on table "public"."series" to "anon";

grant references on table "public"."series" to "anon";

grant select on table "public"."series" to "anon";

grant trigger on table "public"."series" to "anon";

grant truncate on table "public"."series" to "anon";

grant update on table "public"."series" to "anon";

grant delete on table "public"."series" to "authenticated";

grant insert on table "public"."series" to "authenticated";

grant references on table "public"."series" to "authenticated";

grant select on table "public"."series" to "authenticated";

grant trigger on table "public"."series" to "authenticated";

grant truncate on table "public"."series" to "authenticated";

grant update on table "public"."series" to "authenticated";

grant delete on table "public"."series" to "service_role";

grant insert on table "public"."series" to "service_role";

grant references on table "public"."series" to "service_role";

grant select on table "public"."series" to "service_role";

grant trigger on table "public"."series" to "service_role";

grant truncate on table "public"."series" to "service_role";

grant update on table "public"."series" to "service_role";

grant delete on table "public"."users" to "anon";

grant insert on table "public"."users" to "anon";

grant references on table "public"."users" to "anon";

grant select on table "public"."users" to "anon";

grant trigger on table "public"."users" to "anon";

grant truncate on table "public"."users" to "anon";

grant update on table "public"."users" to "anon";

grant delete on table "public"."users" to "authenticated";

grant insert on table "public"."users" to "authenticated";

grant references on table "public"."users" to "authenticated";

grant select on table "public"."users" to "authenticated";

grant trigger on table "public"."users" to "authenticated";

grant truncate on table "public"."users" to "authenticated";

grant update on table "public"."users" to "authenticated";

grant delete on table "public"."users" to "service_role";

grant insert on table "public"."users" to "service_role";

grant references on table "public"."users" to "service_role";

grant select on table "public"."users" to "service_role";

grant trigger on table "public"."users" to "service_role";

grant truncate on table "public"."users" to "service_role";

grant update on table "public"."users" to "service_role";

create policy "Allow delete for admin/staff only"
on "public"."activities"
as permissive
for delete
to public
using ((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])));


create policy "Enable insert for admin/staff only"
on "public"."activities"
as permissive
for insert
to public
with check ((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])));


create policy "Enable update for admin/staff only"
on "public"."activities"
as permissive
for update
to public
using ((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])));


create policy "Return data based on user role"
on "public"."activities"
as permissive
for select
to public
using (((( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'admin'::roles_user) OR (( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'staff'::roles_user) OR ((( SELECT users.role
   FROM users
  WHERE (users.id = auth.uid())) = 'faculty'::roles_user) AND (visibility = ANY (ARRAY['Faculty'::activity_visibility, 'Everyone'::activity_visibility]))) OR (visibility = 'Everyone'::activity_visibility)));


create policy "Allow deletes for admin/staff only"
on "public"."activity_feedback"
as permissive
for delete
to public
using ((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])));


create policy "Allow public inserts"
on "public"."activity_feedback"
as permissive
for insert
to public
with check (true);


create policy "Enable read access for admin/staff users"
on "public"."activity_feedback"
as permissive
for select
to public
using ((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])));


create policy "Enable updates for admin/staff users"
on "public"."activity_feedback"
as permissive
for update
to public
using ((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])))
with check ((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])));


create policy "only allow admin/staffs"
on "public"."activity_files"
as permissive
for all
to public
using ((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])));


create policy "Enable delete for users based on user_id"
on "public"."activity_subscriptions"
as permissive
for delete
to public
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Enable insert for authenticated users only"
on "public"."activity_subscriptions"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."activity_subscriptions"
as permissive
for select
to public
using (true);


create policy "Enable update for users based on id"
on "public"."activity_subscriptions"
as permissive
for update
to public
using ((( SELECT auth.uid() AS uid) = user_id))
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Enable changes from admin and staff only"
on "public"."allowed_domains"
as permissive
for all
to public
using ((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])))
with check ((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])));


create policy "Enable actions for internal users"
on "public"."analytics_metadata"
as permissive
for all
to authenticated
using ((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])));


create policy "Enable delete for elevated users"
on "public"."certs"
as permissive
for delete
to public
using (((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])) OR (( SELECT users.other_roles
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) && ARRAY['chair'::roles_pos, 'dean'::roles_pos])));


create policy "Enable insert for elevated users"
on "public"."certs"
as permissive
for insert
to public
with check (((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])) OR (( SELECT users.other_roles
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) && ARRAY['chair'::roles_pos, 'dean'::roles_pos])));


create policy "Enable read access for all users"
on "public"."certs"
as permissive
for select
to public
using (true);


create policy "Enable updates for elevated users"
on "public"."certs"
as permissive
for update
to public
using (((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])) OR (( SELECT users.other_roles
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) && ARRAY['chair'::roles_pos, 'dean'::roles_pos])));


create policy "Elevated users + faculty rsvp"
on "public"."faculty_assignments"
as permissive
for update
to public
using (((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])) OR (( SELECT users.other_roles
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) && ARRAY['chair'::roles_pos, 'dean'::roles_pos]) OR ( SELECT (auth.uid() = faculty_assignments.user_id))));


create policy "Enable delete for elevated users"
on "public"."faculty_assignments"
as permissive
for delete
to public
using (((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])) OR (( SELECT users.other_roles
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) && ARRAY['chair'::roles_pos, 'dean'::roles_pos])));


create policy "Enable insert for elevated users"
on "public"."faculty_assignments"
as permissive
for insert
to public
with check (((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])) OR (( SELECT users.other_roles
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) && ARRAY['chair'::roles_pos, 'dean'::roles_pos])));


create policy "Enable read access for all users"
on "public"."faculty_assignments"
as permissive
for select
to public
using (true);


create policy "Enable delete for admin/staff only"
on "public"."series"
as permissive
for delete
to authenticated
using ((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])));


create policy "Enable insert for admin/staff only"
on "public"."series"
as permissive
for insert
to authenticated
with check ((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])));


create policy "Enable read access for all users"
on "public"."series"
as permissive
for select
to public
using (true);


create policy "Enable update for admin/staff only"
on "public"."series"
as permissive
for update
to authenticated
using ((( SELECT users.role
   FROM users
  WHERE (users.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])));


create policy "Enable delete for admin/staff only"
on "public"."users"
as permissive
for delete
to public
using ((( SELECT users_1.role
   FROM users users_1
  WHERE (users_1.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])));


create policy "Enable inserts for admin/staff"
on "public"."users"
as permissive
for insert
to public
with check ((( SELECT users_1.role
   FROM users users_1
  WHERE (users_1.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])));


create policy "Enable read access for all users"
on "public"."users"
as permissive
for select
to public
using (true);


create policy "Enable update for admin/staff only"
on "public"."users"
as permissive
for update
to public
using ((( SELECT users_1.role
   FROM users users_1
  WHERE (users_1.id = ( SELECT auth.uid() AS uid))) = ANY (ARRAY['admin'::roles_user, 'staff'::roles_user])));


CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.activities FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.analytics_metadata FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.users FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');

CREATE TRIGGER update_raw_app_meta_data_trigger AFTER UPDATE OF role, active ON public.users FOR EACH ROW WHEN (((old.role IS DISTINCT FROM new.role) OR (old.active IS DISTINCT FROM new.active))) EXECUTE FUNCTION update_raw_app_meta_data();


